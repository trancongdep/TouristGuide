
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>D·∫´n ƒê∆∞·ªùng & C·∫£nh B√°o T·ªëc ƒê·ªô</title>
    <meta name="theme-color" content="#a73b24">
    <link rel="manifest" href="manifest.json">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* Dashboard T·ªëc ƒê·ªô */
        #speed-dashboard {
            background: #212529;
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 1001;
            transition: background 0.3s;
        }
        #speed-dashboard.warning {
            background: #dc3545; /* ƒê·ªè khi qu√° t·ªëc ƒë·ªô */
            animation: flash 1s infinite;
        }
        @keyframes flash { 0% { opacity: 1; } 50% { opacity: 0.8; } 100% { opacity: 1; } }

        .speed-box {
            text-align: center;
        }
        .speed-value {
            font-size: 2rem;
            font-weight: bold;
            display: block;
            font-variant-numeric: tabular-nums;
        }
        .speed-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: #adb5bd;
        }
        .limit-circle {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #dc3545;
            background: white;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
        }

        /* Khu v·ª±c ƒëi·ªÅu khi·ªÉn */
        .controls {
            background: white;
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        .input-group { display: flex; gap: 5px; margin-bottom: 5px; }
        input { flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .btn-search { background: #0d6efd; color: white; border: none; padding: 8px; border-radius: 4px; }
        .action-group { display: flex; gap: 5px; }
        button { padding: 10px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; flex: 1; }
        .btn-go { background-color: #198754; color: white; }
        .btn-stop { background-color: #6c757d; color: white; }

        #status { font-size: 0.8rem; color: #666; margin-top: 5px; font-style: italic; text-align: center;}

        /* Layout B·∫£n ƒë·ªì & List */
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        #map { height: 50%; width: 100%; background: #e5e3df; }
        #places-list {
            height: 50%;
            overflow-y: auto;
            padding: 10px;
            list-style: none;
            margin: 0;
            background: #f8f9fa;
        }
        
        .place-card {
            background: white;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #ddd;
            font-size: 0.9rem;
        }
        .place-card.active { border-left-color: #a73b24; background-color: #fff5f5; }
        .place-title { font-weight: bold; color: #a73b24; }
        .badge { display: inline-block; padding: 2px 5px; border-radius: 3px; font-size: 0.7em; color: white; margin-left: 5px; }
        .badge-route { background: #198754; }
    </style>
</head>
<body>

<div id="speed-dashboard">
    <div class="speed-box">
        <span class="speed-value" id="current-speed">0</span>
        <span class="speed-label">km/h</span>
    </div>
    
    <div class="limit-circle">
        <span id="speed-limit">--</span>
    </div>

    <div class="speed-box">
        <span class="speed-value" id="dist-next">--</span>
        <span class="speed-label">Di t√≠ch g·∫ßn nh·∫•t</span>
    </div>
</div>

<div class="controls">
    <div class="input-group">
        <input type="text" id="destination-input" placeholder="Nh·∫≠p ƒëi·ªÉm ƒë·∫øn (VD: H·ªì G∆∞∆°m)">
        <button class="btn-search" onclick="searchDestination()">üîç</button>
    </div>
    <div class="action-group">
        <button class="btn-go" onclick="calculateRouteAndScan()">üöó ƒêi & Qu√©t</button>
        <button class="btn-stop" onclick="stopTour()">‚èπ D·ª´ng</button>
    </div>
    <div id="status">S·∫µn s√†ng...</div>
</div>

<div id="main-content">
    <div id="map"></div>
    <ul id="places-list"></ul>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCzWjfcD5Dgq7V-i2izb9tKLR6QM6qWPQo",
    authDomain: "tavietnam-78ae8.firebaseapp.com",
    projectId: "tavietnam-78ae8",
    storageBucket: "tavietnam-78ae8.firebasestorage.app",
    messagingSenderId: "670121705534",
    appId: "1:670121705534:web:1027ad98550573ad37116f"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  console.log("Firebase v1.5 initialized");
</script>

<script>
    // --- VARIABLES ---
    const map = L.map('map').setView([10.8231, 106.6297], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    let userMarker, destMarker, routePolyline;
    let currentLat, currentLon;
    let synth = window.speechSynthesis;
    let placesQueue = [];
    let alreadyReadIds = [];
    let isTourActive = false;
    let currentLimit = null; // T·ªëc ƒë·ªô gi·ªõi h·∫°n hi·ªán t·∫°i
    let lastOverpassCall = 0; // ƒê·ªÉ h·∫°n ch·∫ø g·ªçi API li√™n t·ª•c

    // DOM Elements
    const statusEl = document.getElementById('status');
    const listEl = document.getElementById('places-list');
    const elSpeed = document.getElementById('current-speed');
    const elLimit = document.getElementById('speed-limit');
    const elDashboard = document.getElementById('speed-dashboard');
    const elDist = document.getElementById('dist-next');

    // --- 1. GEOLOCATION & SPEEDOMETER ---
    function initLocation() {
        if (!navigator.geolocation) return updateStatus("Kh√¥ng h·ªó tr·ª£ GPS");
        
        navigator.geolocation.watchPosition(
            (pos) => {
                currentLat = pos.coords.latitude;
                currentLon = pos.coords.longitude;
                const speedMps = pos.coords.speed || 0; // m/s
                const speedKmh = Math.round(speedMps * 3.6); // Convert to km/h
                
                // Update UI
                elSpeed.innerText = speedKmh;
                updateMapPosition(currentLat, currentLon);

                // Logic ch√≠nh khi ƒëang di chuy·ªÉn
                if (isTourActive) {
                    checkProximityToRead(); // Qu√©t di t√≠ch
                    checkSpeedLimit(speedKmh, currentLat, currentLon); // Ki·ªÉm tra t·ªëc ƒë·ªô
                }
            },
            (err) => console.error(err),
            { enableHighAccuracy: true, maximumAge: 1000 }
        );
    }
    initLocation();

    function updateMapPosition(lat, lon) {
        if (!userMarker) {
            userMarker = L.marker([lat, lon], {zIndexOffset: 1000}).addTo(map);
            map.setView([lat, lon], 15);
        } else {
            userMarker.setLatLng([lat, lon]);
        }
    }

    // --- 2. CHECK SPEED LIMIT (OVERPASS API) ---
    async function checkSpeedLimit(currentSpeed, lat, lon) {
        // Ch·ªâ g·ªçi API m·ªói 15 gi√¢y ƒë·ªÉ tr√°nh b·ªã block (Overpass limit)
        const now = Date.now();
        if (now - lastOverpassCall < 15000) {
            validateSpeed(currentSpeed);
            return;
        }
        lastOverpassCall = now;

        // Query: T√¨m c√°c con ƒë∆∞·ªùng (way) trong b√°n k√≠nh 20m c√≥ th·∫ª maxspeed
        const query = `
            [out:json];
            way(around:20, ${lat}, ${lon})["maxspeed"];
            out tags;
        `;
        const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

        try {
            const res = await fetch(url);
            const data = await res.json();
            
            if (data.elements && data.elements.length > 0) {
                // L·∫•y maxspeed c·ªßa con ƒë∆∞·ªùng ƒë·∫ßu ti√™n t√¨m th·∫•y
                let maxSpeedTag = data.elements[0].tags.maxspeed;
                // X·ª≠ l√Ω d·ªØ li·ªáu (VD: "50", "60 km/h", "VN:urban")
                let limit = parseInt(maxSpeedTag);
                
                if (!isNaN(limit)) {
                    currentLimit = limit;
                    elLimit.innerText = limit;
                } else {
                    currentLimit = null;
                    elLimit.innerText = "--";
                }
            }
        } catch (e) { console.error("L·ªói l·∫•y t·ªëc ƒë·ªô:", e); }
        
        validateSpeed(currentSpeed);
    }

    function validateSpeed(currentSpeed) {
        if (currentLimit && currentSpeed > currentLimit + 5) { // Cho ph√©p sai s·ªë 5km/h
            elDashboard.classList.add('warning');
            updateStatus("‚ö†Ô∏è C·∫¢NH B√ÅO: B·∫†N ƒêANG CH·∫†Y QU√Å T·ªêC ƒê·ªò!");
            // K√™u b√≠p c·∫£nh b√°o (n·∫øu c·∫ßn thi·∫øt c√≥ th·ªÉ th√™m √¢m thanh)
        } else {
            elDashboard.classList.remove('warning');
        }
    }

    // --- 3. ROUTING & PLACES (Logic t·ª´ v1.4) ---
    async function searchDestination() {
        const query = document.getElementById('destination-input').value;
        if (!query) return alert("Nh·∫≠p ƒëi·ªÉm ƒë·∫øn!");
        updateStatus("ƒêang t√¨m...");
        
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=vn&limit=1`);
        const data = await res.json();
        
        if (data.length === 0) return updateStatus("Kh√¥ng t√¨m th·∫•y.");
        const dest = data[0];
        
        if (destMarker) map.removeLayer(destMarker);
        destMarker = L.marker([dest.lat, dest.lon]).addTo(map).bindPopup("ƒêi·ªÉm ƒë·∫øn").openPopup();
        map.fitBounds(L.featureGroup([userMarker, destMarker]).getBounds().pad(0.2));
        
        updateStatus("ƒê√£ ch·ªçn ƒëi·ªÉm ƒë·∫øn.");
    }

    async function calculateRouteAndScan() {
        if (!destMarker) return alert("Vui l√≤ng ch·ªçn ƒëi·ªÉm ƒë·∫øn tr∆∞·ªõc.");
        
        isTourActive = true;
        listEl.innerHTML = '';
        alreadyReadIds = [];
        updateStatus("ƒêang t√≠nh to√°n l·ªô tr√¨nh...");
        
        const destPos = destMarker.getLatLng();
        const url = `https://router.project-osrm.org/route/v1/driving/${currentLon},${currentLat};${destPos.lng},${destPos.lat}?overview=full&geometries=geojson`;
        
        try {
            const res = await fetch(url);
            const data = await res.json();
            if (data.code !== 'Ok') return updateStatus("L·ªói ƒë∆∞·ªùng ƒëi.");
            
            // V·∫Ω ƒë∆∞·ªùng
            const route = data.routes[0];
            const coordinates = route.geometry.coordinates;
            const latLngs = coordinates.map(c => [c[1], c[0]]);
            
            if (routePolyline) map.removeLayer(routePolyline);
            routePolyline = L.polyline(latLngs, {color: 'blue', weight: 5}).addTo(map);
            map.fitBounds(routePolyline.getBounds());
            
            // Qu√©t ƒë·ªãa ƒëi·ªÉm (L·∫•y m·∫´u t·ªça ƒë·ªô tr√™n ƒë∆∞·ªùng ƒë·ªÉ qu√©t)
            const samplePoints = [];
            const step = Math.max(20, Math.floor(coordinates.length / 10));
            for(let i=0; i<coordinates.length; i+=step) {
                samplePoints.push({lat: coordinates[i][1], lon: coordinates[i][0]});
            }
            scanPlacesAlongRoute(samplePoints);

        } catch (e) { updateStatus("L·ªói routing."); }
    }

    async function scanPlacesAlongRoute(points) {
        // Qu√©t song song
        updateStatus("ƒêang qu√©t d·ªØ li·ªáu l·ªãch s·ª≠...");
        let allPlaces = new Map();
        const promises = points.map(pt => 
            fetch(`https://vi.wikipedia.org/w/api.php?action=query&list=geosearch&gscoord=${pt.lat}|${pt.lon}&gsradius=2000&gslimit=10&format=json&origin=*`).then(r=>r.json())
        );
        const results = await Promise.all(promises);
        
        results.forEach(d => {
            if(d.query?.geosearch) d.query.geosearch.forEach(p => allPlaces.set(p.pageid, p));
        });

        const ids = Array.from(allPlaces.keys()).join('|');
        if(!ids) return updateStatus("Kh√¥ng t√¨m th·∫•y di t√≠ch n√†o.");

        // L·∫•y chi ti·∫øt
        const detailRes = await fetch(`https://vi.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&pageids=${ids}&format=json&origin=*`);
        const detailData = await detailRes.json();
        const pages = detailData.query.pages;
        const PRIORITY = ['ch√πa', 'ƒë√¨nh', 'ƒë·ªÅn', 'mi·∫øu', 'nh√† th·ªù', 'di t√≠ch', 'l·ªãch s·ª≠', 'b·∫£o t√†ng', 'lƒÉng'];

        placesQueue = Array.from(allPlaces.values()).map(p => {
            const details = pages[p.pageid];
            const text = (p.title + " " + (details?.extract || "")).toLowerCase();
            return {
                id: p.pageid, title: p.title, lat: p.lat, lon: p.lon,
                extract: details ? details.extract : "",
                isPriority: PRIORITY.some(k => text.includes(k))
            };
        }).filter(p => p.isPriority || p.extract.length > 50);

        renderList(placesQueue);
        speak(`B·∫Øt ƒë·∫ßu d·∫´n ƒë∆∞·ªùng. T√¥i s·∫Ω c·∫£nh b√°o n·∫øu b·∫°n ch·∫°y qu√° t·ªëc ƒë·ªô v√† thuy·∫øt minh v·ªÅ c√°c di t√≠ch.`, null);
    }

    function renderList(places) {
        listEl.innerHTML = '';
        places.forEach(p => {
            const li = document.createElement('li');
            li.className = `place-card ${p.isPriority ? 'active' : ''}`;
            li.id = `place-${p.id}`;
            li.innerHTML = `<div class="place-title">${p.title}</div><div>${p.extract.substring(0,80)}...</div>`;
            listEl.appendChild(li);
        });
    }

    function checkProximityToRead() {
        if (synth.speaking) return;
        let nearestDist = 9999;
        
        placesQueue.forEach(p => {
            if (alreadyReadIds.includes(p.id)) return;
            const dist = getDist(currentLat, currentLon, p.lat, p.lon);
            if (dist < nearestDist) nearestDist = dist;
            
            if (dist < 800) { // ƒê·ªçc khi ƒë·∫øn g·∫ßn 800m
                alreadyReadIds.push(p.id);
                speak(`S·∫Øp t·ªõi ${p.title}. ${p.extract}`, p.id);
            }
        });
        
        elDist.innerText = nearestDist < 9999 ? Math.round(nearestDist) + "m" : "--";
    }

    function speak(text, id) {
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'vi-VN';
        synth.speak(u);
    }

    function updateStatus(msg) { statusEl.innerText = msg; }
    function stopTour() { isTourActive = false; synth.cancel(); updateStatus("ƒê√£ d·ª´ng."); }
    function getDist(lat1,lon1,lat2,lon2) {
        var R=6371; var dLat=(lat2-lat1)*Math.PI/180; var dLon=(lon2-lon1)*Math.PI/180;
        var a=Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)*Math.sin(dLon/2);
        return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))*1000;
    }
</script>

</body>
</html>
