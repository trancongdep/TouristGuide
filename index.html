<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HDV Du L·ªãch Th√¥ng Minh</title>
    <meta name="theme-color" content="#a73b24">
    <link rel="manifest" href="manifest.json">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        header {
            background-color: #a73b24;
            color: white;
            padding: 10px 15px;
            text-align: center;
            flex-shrink: 0;
            z-index: 1000;
        }
        h1 { margin: 0; font-size: 1.1rem; }
        
        /* Khu v·ª±c ƒëi·ªÅu khi·ªÉn */
        .controls {
            background: white;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 999;
            flex-shrink: 0;
        }
        .input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 1rem;
        }
        .btn-search { background: #0d6efd; color: white; width: 50px; }
        
        .action-group {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            flex: 1;
            font-size: 0.95rem;
        }
        .btn-go { background-color: #198754; color: white; }
        .btn-stop { background-color: #dc3545; color: white; flex: 0.4; }

        #status {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Khu v·ª±c B·∫£n ƒë·ªì v√† List */
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        #map {
            height: 40%; /* B·∫£n ƒë·ªì chi·∫øm 40% m√†n h√¨nh */
            width: 100%;
            background: #e5e3df;
        }

        #places-list {
            height: 60%; /* Danh s√°ch chi·∫øm 60% */
            overflow-y: auto;
            padding: 10px;
            list-style: none;
            margin: 0;
            background: #f8f9fa;
        }
        
        /* Card ƒë·ªãa ƒëi·ªÉm */
        .place-card {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-left: 4px solid #ddd;
        }
        .place-card.on-route {
            border-left-color: #198754; /* M√†u xanh l√°: Tr√™n ƒë∆∞·ªùng ƒëi */
            background-color: #f0fff4;
        }
        .place-card.active {
            border-left-color: #a73b24; /* M√†u ƒë·ªè: ƒêang ƒë·ªçc */
            background-color: #fff5f5;
        }
        
        .place-title { font-weight: bold; font-size: 1rem; color: #a73b24; display: block; margin-bottom: 4px; }
        .place-meta { font-size: 0.75rem; color: #666; margin-bottom: 6px; }
        .place-desc { font-size: 0.9rem; color: #333; line-height: 1.4; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
        
        .badge {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.7em;
            color: white;
            margin-left: 5px;
            vertical-align: middle;
        }
        .badge-route { background: #198754; }
        
        .speaking-icon { display: none; margin-left: 5px; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 0.5; transform: scale(0.9); } 100% { opacity: 1; transform: scale(1.1); } }
    </style>
</head>
<body>

<header>
    <h1>D·∫´n ƒê∆∞·ªùng & Thuy·∫øt Minh <span id="version" style="font-size:0.7em; opacity:0.8">v1.4</span></h1>
</header>

<div class="controls">
    <div class="input-group">
        <input type="text" id="destination-input" placeholder="Nh·∫≠p ƒëi·ªÉm ƒë·∫øn (VD: H·ªì G∆∞∆°m)">
        <button class="btn-search" onclick="searchDestination()">üîç</button>
    </div>
    <div class="action-group">
        <button class="btn-go" onclick="calculateRouteAndScan()">üöó T√¨m ƒë∆∞·ªùng & Qu√©t</button>
        <button class="btn-stop" onclick="stopTour()">‚èπ D·ª´ng</button>
    </div>
    <div id="status">Nh·∫≠p ƒëi·ªÉm ƒë·∫øn ƒë·ªÉ b·∫Øt ƒë·∫ßu...</div>
</div>

<div id="main-content">
    <div id="map"></div>
    <ul id="places-list">
        </ul>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCzWjfcD5Dgq7V-i2izb9tKLR6QM6qWPQo",
    authDomain: "tavietnam-78ae8.firebaseapp.com",
    projectId: "tavietnam-78ae8",
    storageBucket: "tavietnam-78ae8.firebasestorage.app",
    messagingSenderId: "670121705534",
    appId: "1:670121705534:web:1027ad98550573ad37116f"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  console.log("Firebase v1.4 initialized");
</script>

<script>
    // --- KH·ªûI T·∫†O B·∫¢N ƒê·ªí ---
    const map = L.map('map').setView([10.8231, 106.6297], 13); // M·∫∑c ƒë·ªãnh HCM
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap'
    }).addTo(map);

    let userMarker, destMarker, routePolyline;
    let currentLat, currentLon;
    
    // --- VARIABLES ---
    const statusEl = document.getElementById('status');
    const listEl = document.getElementById('places-list');
    let synth = window.speechSynthesis;
    let placesQueue = [];
    let alreadyReadIds = [];
    let isTourActive = false;

    // C√°c t·ª´ kh√≥a ∆∞u ti√™n
    const PRIORITY_KEYWORDS = ['ch√πa', 'ƒë√¨nh', 'ƒë·ªÅn', 'mi·∫øu', 'nh√† th·ªù', 'di t√≠ch', 'l·ªãch s·ª≠', 'b·∫£o t√†ng', 'lƒÉng', 'th√°p', 'c·ªïng', 'c√¥ng vi√™n'];

    // --- GEOLOCATION ---
    function updateStatus(msg) { statusEl.textContent = msg; }

    function initLocation() {
        if (!navigator.geolocation) return updateStatus("Kh√¥ng h·ªó tr·ª£ GPS");
        navigator.geolocation.watchPosition(
            (pos) => {
                currentLat = pos.coords.latitude;
                currentLon = pos.coords.longitude;
                
                // C·∫≠p nh·∫≠t marker tr√™n b·∫£n ƒë·ªì
                if (!userMarker) {
                    userMarker = L.marker([currentLat, currentLon], {title: "B·∫°n ·ªü ƒë√¢y"}).addTo(map).bindPopup("V·ªã tr√≠ c·ªßa b·∫°n").openPopup();
                    map.setView([currentLat, currentLon], 14);
                } else {
                    userMarker.setLatLng([currentLat, currentLon]);
                }

                // N·∫øu ƒëang trong ch·∫ø ƒë·ªô tour th√¨ ki·ªÉm tra kho·∫£ng c√°ch t·ªõi c√°c ƒëi·ªÉm ƒë·ªÉ ƒë·ªçc
                if (isTourActive) checkProximityToRead();
            },
            (err) => console.error(err),
            { enableHighAccuracy: true }
        );
    }
    initLocation();

    // --- T√åM ƒêI·ªÇM ƒê·∫æN (Nominatim API) ---
    async function searchDestination() {
        const query = document.getElementById('destination-input').value;
        if (!query) return alert("Vui l√≤ng nh·∫≠p ƒëi·ªÉm ƒë·∫øn!");
        
        updateStatus("ƒêang t√¨m ƒë·ªãa ƒëi·ªÉm...");
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=vn&limit=1`;
        
        try {
            const res = await fetch(url);
            const data = await res.json();
            if (data.length === 0) return updateStatus("Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm n√†y.");
            
            const dest = data[0];
            const destLat = parseFloat(dest.lat);
            const destLon = parseFloat(dest.lon);
            
            if (destMarker) map.removeLayer(destMarker);
            destMarker = L.marker([destLat, destLon]).addTo(map).bindPopup(dest.display_name).openPopup();
            
            // Zoom ƒë·ªÉ th·∫•y c·∫£ 2 ƒëi·ªÉm
            if (userMarker) {
                const group = new L.featureGroup([userMarker, destMarker]);
                map.fitBounds(group.getBounds().pad(0.2));
            }
            
            updateStatus("ƒê√£ ch·ªçn: " + dest.display_name.split(',')[0]);
            return { lat: destLat, lon: destLon };
        } catch (e) { updateStatus("L·ªói t√¨m ki·∫øm."); }
    }

    // --- T√çNH ƒê∆Ø·ªúNG ƒêI & QU√âT (OSRM Routing) ---
    async function calculateRouteAndScan() {
        if (!currentLat || !destMarker) {
            // N·∫øu ch∆∞a t√¨m ƒëi·ªÉm ƒë·∫øn, t√¨m tr∆∞·ªõc
            const dest = await searchDestination();
            if (!dest) return;
        }
        
        isTourActive = true;
        listEl.innerHTML = '';
        updateStatus("ƒêang t√≠nh ƒë∆∞·ªùng ƒëi v√† qu√©t di t√≠ch...");
        
        const destPos = destMarker.getLatLng();
        
        // G·ªçi OSRM API (Free)
        const url = `https://router.project-osrm.org/route/v1/driving/${currentLon},${currentLat};${destPos.lng},${destPos.lat}?overview=full&geometries=geojson`;
        
        try {
            const res = await fetch(url);
            const data = await res.json();
            
            if (data.code !== 'Ok') return updateStatus("Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng ƒëi.");
            
            const route = data.routes[0];
            const coordinates = route.geometry.coordinates; // M·∫£ng [[lon, lat], ...]
            
            // V·∫Ω ƒë∆∞·ªùng ƒëi l√™n b·∫£n ƒë·ªì
            if (routePolyline) map.removeLayer(routePolyline);
            // ƒê·∫£o ng∆∞·ª£c [lon, lat] th√†nh [lat, lon] cho Leaflet
            const latLngs = coordinates.map(coord => [coord[1], coord[0]]);
            routePolyline = L.polyline(latLngs, {color: 'blue', weight: 5, opacity: 0.7}).addTo(map);
            map.fitBounds(routePolyline.getBounds());
            
            // THU·∫¨T TO√ÅN QU√âT D·ªåC ƒê∆Ø·ªúNG:
            // L·∫•y m·∫´u c√°c ƒëi·ªÉm tr√™n ƒë∆∞·ªùng ƒëi (VD: m·ªói 20 ƒëi·ªÉm l·∫•y 1 ƒëi·ªÉm ƒë·ªÉ qu√©t)
            const samplePoints = [];
            const step = Math.max(20, Math.floor(coordinates.length / 10)); // L·∫•y kho·∫£ng 10-15 ƒëi·ªÉm m·∫´u
            
            for(let i = 0; i < coordinates.length; i += step) {
                samplePoints.push({ lat: coordinates[i][1], lon: coordinates[i][0] });
            }
            // Lu√¥n th√™m ƒëi·ªÉm cu·ªëi
            samplePoints.push({ lat: destPos.lat, lon: destPos.lng });
            
            updateStatus(`ƒêang qu√©t ${samplePoints.length} khu v·ª±c d·ªçc l·ªô tr√¨nh...`);
            scanPlacesAlongRoute(samplePoints);
            
        } catch (e) { updateStatus("L·ªói t√≠nh ƒë∆∞·ªùng: " + e.message); }
    }

    // --- QU√âT WIKIPEDIA D·ªåC L·ªò TR√åNH ---
    async function scanPlacesAlongRoute(points) {
        let allPlaces = new Map(); // D√πng Map ƒë·ªÉ l·ªçc tr√πng l·∫∑p ID
        
        // S·ª≠ d·ª•ng Promise.all ƒë·ªÉ qu√©t song song
        const promises = points.map(pt => 
            fetch(`https://vi.wikipedia.org/w/api.php?action=query&list=geosearch&gscoord=${pt.lat}|${pt.lon}&gsradius=2000&gslimit=10&format=json&origin=*`)
            .then(res => res.json())
        );
        
        const results = await Promise.all(promises);
        
        // G·ªôp k·∫øt qu·∫£
        results.forEach(data => {
            if (data.query && data.query.geosearch) {
                data.query.geosearch.forEach(p => {
                    allPlaces.set(p.pageid, p);
                });
            }
        });
        
        // L·∫•y chi ti·∫øt n·ªôi dung
        const uniqueIds = Array.from(allPlaces.keys()).join('|');
        if (!uniqueIds) return updateStatus("Kh√¥ng th·∫•y ƒë·ªãa ƒëi·ªÉm n√†o d·ªçc ƒë∆∞·ªùng.");
        
        fetchPlaceDetails(uniqueIds, Array.from(allPlaces.values()));
    }

    async function fetchPlaceDetails(ids, basicPlaces) {
        // Chia nh·ªè request n·∫øu qu√° d√†i (Wikipedia gi·ªõi h·∫°n kho·∫£ng 50 ID)
        // ·ªû ƒë√¢y l√†m ƒë∆°n gi·∫£n gi·∫£ s·ª≠ < 50
        const url = `https://vi.wikipedia.org/w/api.php?action=query&prop=extracts&exintro&explaintext&pageids=${ids}&format=json&origin=*`;
        
        const res = await fetch(url);
        const data = await res.json();
        const pages = data.query.pages;
        
        let finalPlaces = basicPlaces.map(p => {
            const details = pages[p.pageid];
            const text = (p.title + " " + (details?.extract || "")).toLowerCase();
            const isPriority = PRIORITY_KEYWORDS.some(k => text.includes(k));
            
            return {
                id: p.pageid,
                title: p.title,
                lat: p.lat,
                lon: p.lon,
                extract: details ? details.extract : "",
                isPriority: isPriority,
                read: false
            };
        });
        
        // L·ªçc: Ch·ªâ l·∫•y Priority (L·ªãch s·ª≠) HO·∫∂C n·∫±m r·∫•t g·∫ßn
        finalPlaces = finalPlaces.filter(p => p.isPriority || p.extract.length > 50);
        
        // L∆∞u v√†o h√†ng ƒë·ª£i to√†n c·ª•c ƒë·ªÉ check khi di chuy·ªÉn
        placesQueue = finalPlaces;
        renderList(finalPlaces);
        
        speak(`ƒê√£ t√¨m th·∫•y ƒë∆∞·ªùng ƒëi v√† ${finalPlaces.length} ƒë·ªãa ƒëi·ªÉm l·ªãch s·ª≠ d·ªçc l·ªô tr√¨nh. B·∫Øt ƒë·∫ßu xu·∫•t ph√°t!`, null);
    }

    function renderList(places) {
        listEl.innerHTML = '';
        places.forEach(p => {
            const li = document.createElement('li');
            li.className = `place-card ${p.isPriority ? 'on-route' : ''}`;
            li.id = `place-${p.id}`;
            const badge = p.isPriority ? '<span class="badge badge-route">Di t√≠ch</span>' : '';
            
            li.innerHTML = `
                <span class="place-title">${p.title} ${badge} <span class="speaking-icon">üîä</span></span>
                <div class="place-meta">T·ªça ƒë·ªô: ${p.lat.toFixed(4)}, ${p.lon.toFixed(4)}</div>
                <div class="place-desc">${truncate(p.extract, 100)}</div>
            `;
            listEl.appendChild(li);
        });
    }

    // --- CHECK KHO·∫¢NG C√ÅCH KHI DI CHUY·ªÇN ---
    function checkProximityToRead() {
        if (!isTourActive || synth.speaking) return;
        
        // T√¨m ƒë·ªãa ƒëi·ªÉm g·∫ßn nh·∫•t trong b√°n k√≠nh 500m ch∆∞a ƒë·ªçc
        let nearestPlace = null;
        let minDesc = 999999;
        
        placesQueue.forEach(p => {
            if (alreadyReadIds.includes(p.id)) return;
            
            const dist = getDistanceFromLatLonInM(currentLat, currentLon, p.lat, p.lon);
            
            // C·∫≠p nh·∫≠t kho·∫£ng c√°ch hi·ªÉn th·ªã (Optional)
            
            if (dist < 800) { // N·∫øu ƒëi v√†o v√πng 800m quanh ƒë·ªãa ƒëi·ªÉm
                if (dist < minDesc) {
                    minDesc = dist;
                    nearestPlace = p;
                }
            }
        });
        
        if (nearestPlace) {
            alreadyReadIds.push(nearestPlace.id);
            speak(`S·∫Øp ƒë·∫øn ${nearestPlace.title}. ${nearestPlace.extract}`, nearestPlace.id);
        }
    }

    function speak(text, id) {
        if (!text) return;
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'vi-VN';
        u.onstart = () => {
            if (id) {
                document.querySelectorAll('.place-card').forEach(el => el.classList.remove('active'));
                const el = document.getElementById(`place-${id}`);
                if (el) {
                    el.classList.add('active');
                    el.querySelector('.speaking-icon').style.display = 'inline-block';
                    el.scrollIntoView({behavior: "smooth", block: "center"});
                }
            }
        };
        u.onend = () => {
             if (id) {
                 const el = document.getElementById(`place-${id}`);
                 if(el) {
                     el.classList.remove('active');
                     el.querySelector('.speaking-icon').style.display = 'none';
                 }
             }
        };
        synth.speak(u);
    }

    function stopTour() {
        isTourActive = false;
        synth.cancel();
        updateStatus("ƒê√£ d·ª´ng tour.");
    }
    
    function truncate(str, n){
        return (str.length > n) ? str.substr(0, n-1) + '...' : str;
    }

    // Haversine formula
    function getDistanceFromLatLonInM(lat1,lon1,lat2,lon2) {
        var R = 6371; 
        var dLat = deg2rad(lat2-lat1); 
        var dLon = deg2rad(lon2-lon1); 
        var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2); 
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
        var d = R * c; 
        return d * 1000;
    }
    function deg2rad(deg) { return deg * (Math.PI/180); }
</script>

</body>
</html>

